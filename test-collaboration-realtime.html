<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real-Time Collaboration Test</title>
    <style>
        body {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            background: #000;
            color: #fff;
            margin: 0;
            padding: 20px;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .editor-container {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }
        .editor {
            flex: 1;
            background: #111;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 15px;
        }
        .editor h3 {
            margin: 0 0 10px 0;
            color: #0ea5e9;
        }
        textarea {
            width: 100%;
            height: 300px;
            background: #000;
            color: #fff;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 10px;
            font-family: inherit;
            font-size: 14px;
            resize: vertical;
        }
        .status {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ef4444;
        }
        .status-dot.connected {
            background: #10b981;
        }
        .status-dot.connecting {
            background: #f59e0b;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .controls {
            margin-bottom: 20px;
        }
        button {
            background: #0ea5e9;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
        }
        button:hover {
            background: #0284c7;
        }
        button:disabled {
            background: #374151;
            cursor: not-allowed;
        }
        .log {
            background: #111;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
            height: 200px;
            overflow-y: auto;
            font-size: 12px;
        }
        .log-entry {
            margin-bottom: 5px;
            opacity: 0.8;
        }
        .log-entry.error {
            color: #ef4444;
        }
        .log-entry.success {
            color: #10b981;
        }
        .log-entry.info {
            color: #0ea5e9;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸš€ Real-Time Collaboration Test</h1>
        <p>Test the real-time code synchronization between multiple editor instances.</p>
        
        <div class="controls">
            <button id="connectBtn">Connect to Collaboration</button>
            <button id="disconnectBtn" disabled>Disconnect</button>
            <button id="clearLog">Clear Log</button>
        </div>

        <div class="editor-container">
            <div class="editor">
                <div class="status">
                    <div class="status-dot" id="status1"></div>
                    <span id="statusText1">Disconnected</span>
                </div>
                <h3>Editor 1 (You)</h3>
                <textarea id="editor1" placeholder="Start typing to test real-time sync...">// Welcome to Kriya IDE Real-Time Collaboration Test
// Type here and see changes appear in Editor 2 instantly

function helloWorld() {
    console.log("Hello from Editor 1!");
    return "Real-time collaboration is working!";
}

// Try editing this code and watch it sync in real-time</textarea>
            </div>
            
            <div class="editor">
                <div class="status">
                    <div class="status-dot" id="status2"></div>
                    <span id="statusText2">Simulated Remote User</span>
                </div>
                <h3>Editor 2 (Remote User Simulation)</h3>
                <textarea id="editor2" readonly placeholder="Remote changes will appear here..."></textarea>
            </div>
        </div>

        <div class="log" id="log">
            <div class="log-entry info">Ready to test real-time collaboration...</div>
        </div>
    </div>

    <script>
        class CollaborationTest {
            constructor() {
                this.ws = null;
                this.isConnected = false;
                this.documentId = 'test-document-' + Date.now();
                this.userId = 'user-' + Math.random().toString(36).substr(2, 9);
                this.isApplyingRemoteChange = false;
                
                this.editor1 = document.getElementById('editor1');
                this.editor2 = document.getElementById('editor2');
                this.connectBtn = document.getElementById('connectBtn');
                this.disconnectBtn = document.getElementById('disconnectBtn');
                this.clearLogBtn = document.getElementById('clearLog');
                this.log = document.getElementById('log');
                
                this.setupEventListeners();
                this.logMessage('info', `Test initialized with Document ID: ${this.documentId}`);
                this.logMessage('info', `User ID: ${this.userId}`);
            }
            
            setupEventListeners() {
                this.connectBtn.addEventListener('click', () => this.connect());
                this.disconnectBtn.addEventListener('click', () => this.disconnect());
                this.clearLogBtn.addEventListener('click', () => this.clearLog());
                
                // Track changes in editor 1
                this.editor1.addEventListener('input', (e) => {
                    if (!this.isApplyingRemoteChange && this.isConnected) {
                        this.sendOperation({
                            type: 'replace',
                            content: e.target.value,
                            position: 0,
                            length: e.target.value.length
                        });
                    }
                });
            }
            
            connect() {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.logMessage('info', 'Already connected');
                    return;
                }
                
                this.updateStatus('connecting', 'Connecting...');
                this.logMessage('info', 'Connecting to WebSocket...');
                
                const wsUrl = 'ws://localhost:8081';
                const token = btoa(JSON.stringify({ userId: this.userId, token: 'test-token' }));
                
                try {
                    this.ws = new WebSocket(`${wsUrl}?token=${token}`);
                    
                    this.ws.onopen = () => {
                        this.isConnected = true;
                        this.updateStatus('connected', 'Connected');
                        this.logMessage('success', 'WebSocket connected successfully');
                        this.joinDocument();
                        
                        this.connectBtn.disabled = true;
                        this.disconnectBtn.disabled = false;
                    };
                    
                    this.ws.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            this.handleMessage(data);
                        } catch (error) {
                            this.logMessage('error', `Failed to parse message: ${error.message}`);
                        }
                    };
                    
                    this.ws.onclose = () => {
                        this.isConnected = false;
                        this.updateStatus('disconnected', 'Disconnected');
                        this.logMessage('info', 'WebSocket connection closed');
                        
                        this.connectBtn.disabled = false;
                        this.disconnectBtn.disabled = true;
                    };
                    
                    this.ws.onerror = (error) => {
                        this.updateStatus('error', 'Connection Error');
                        this.logMessage('error', `WebSocket error: ${error.message || 'Unknown error'}`);
                    };
                    
                } catch (error) {
                    this.updateStatus('error', 'Connection Failed');
                    this.logMessage('error', `Connection failed: ${error.message}`);
                }
            }
            
            disconnect() {
                if (this.ws) {
                    this.ws.close();
                    this.ws = null;
                }
                this.isConnected = false;
                this.updateStatus('disconnected', 'Disconnected');
                this.logMessage('info', 'Disconnected from collaboration');
                
                this.connectBtn.disabled = false;
                this.disconnectBtn.disabled = true;
            }
            
            joinDocument() {
                if (!this.ws || this.ws.readyState !== WebSocket.OPEN) return;
                
                const message = {
                    action: 'join-document',
                    documentId: this.documentId,
                    mode: 'live'
                };
                
                this.ws.send(JSON.stringify(message));
                this.logMessage('info', `Joining document: ${this.documentId}`);
            }
            
            sendOperation(operation) {
                if (!this.ws || this.ws.readyState !== WebSocket.OPEN) return;
                
                const message = {
                    action: 'operation',
                    documentId: this.documentId,
                    operation: {
                        ...operation,
                        userId: this.userId,
                        timestamp: Date.now()
                    }
                };
                
                this.ws.send(JSON.stringify(message));
                this.logMessage('info', `Sent operation: ${operation.type}`);
            }
            
            handleMessage(data) {
                this.logMessage('info', `Received: ${data.type || 'unknown'}`);
                
                switch (data.type) {
                    case 'document-joined':
                        this.logMessage('success', 'Successfully joined document');
                        if (data.data && data.data.users) {
                            this.logMessage('info', `Active users: ${data.data.users.length}`);
                        }
                        break;
                        
                    case 'operation':
                        this.handleRemoteOperation(data.data || data);
                        break;
                        
                    case 'operation-confirmed':
                        this.logMessage('success', 'Operation confirmed by server');
                        break;
                        
                    case 'user-joined':
                        this.logMessage('info', `User joined: ${data.data?.userId || 'unknown'}`);
                        break;
                        
                    case 'user-left':
                        this.logMessage('info', `User left: ${data.data?.userId || 'unknown'}`);
                        break;
                        
                    default:
                        this.logMessage('info', `Unknown message type: ${data.type}`);
                }
            }
            
            handleRemoteOperation(operationData) {
                if (!operationData || !operationData.operation) return;
                
                const operation = operationData.operation;
                
                // Don't apply our own operations
                if (operation.userId === this.userId) return;
                
                this.logMessage('success', `Applying remote operation from ${operation.userId}`);
                
                // Apply the operation to editor 2 (simulating remote user)
                this.isApplyingRemoteChange = true;
                
                if (operation.type === 'replace' && operation.content !== undefined) {
                    this.editor2.value = operation.content;
                } else if (operation.type === 'insert' && operation.content) {
                    const pos = operation.position || 0;
                    const currentValue = this.editor2.value;
                    this.editor2.value = currentValue.slice(0, pos) + operation.content + currentValue.slice(pos);
                } else if (operation.type === 'delete' && operation.length) {
                    const pos = operation.position || 0;
                    const currentValue = this.editor2.value;
                    this.editor2.value = currentValue.slice(0, pos) + currentValue.slice(pos + operation.length);
                }
                
                setTimeout(() => {
                    this.isApplyingRemoteChange = false;
                }, 100);
            }
            
            updateStatus(status, text) {
                const dot1 = document.getElementById('status1');
                const text1 = document.getElementById('statusText1');
                const dot2 = document.getElementById('status2');
                
                dot1.className = `status-dot ${status}`;
                text1.textContent = text;
                
                if (status === 'connected') {
                    dot2.className = 'status-dot connected';
                } else {
                    dot2.className = 'status-dot';
                }
            }
            
            logMessage(type, message) {
                const entry = document.createElement('div');
                entry.className = `log-entry ${type}`;
                entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
                
                this.log.appendChild(entry);
                this.log.scrollTop = this.log.scrollHeight;
            }
            
            clearLog() {
                this.log.innerHTML = '<div class="log-entry info">Log cleared...</div>';
            }
        }
        
        // Initialize the test
        const collaborationTest = new CollaborationTest();
        
        // Auto-connect for demo
        setTimeout(() => {
            collaborationTest.logMessage('info', 'Auto-connecting in 2 seconds...');
            setTimeout(() => {
                collaborationTest.connect();
            }, 2000);
        }, 1000);
    </script>
</body>
</html>