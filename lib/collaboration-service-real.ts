import { io, Socket } from 'socket.io-client'\n\nexport interface CollaborationUser {\n  readonly id: string\n  readonly name: string\n  readonly avatar: string\n  readonly cursor?: {\n    readonly line: number\n    readonly column: number\n  }\n}\n\nexport interface TextOperation {\n  readonly type: 'insert' | 'delete' | 'replace'\n  readonly position: number\n  readonly content?: string\n  readonly length?: number\n  readonly userId?: string\n  readonly timestamp?: number\n}\n\ntype ConnectionStatus = 'disconnected' | 'connecting' | 'connected' | 'error'\ntype CollaborationMode = 'solo' | 'live'\ntype EventCallback = (data?: unknown) => void\n\nclass RealCollaborationService {\n  private static instance: RealCollaborationService\n  private socket: Socket | null = null\n  private callbacks: Map<string, EventCallback[]> = new Map()\n  private connectionStatus: ConnectionStatus = 'disconnected'\n  private currentDocumentId: string | null = null\n  private reconnectAttempts = 0\n  private maxReconnectAttempts = 5\n\n  static getInstance(): RealCollaborationService {\n    if (!RealCollaborationService.instance) {\n      RealCollaborationService.instance = new RealCollaborationService()\n    }\n    return RealCollaborationService.instance\n  }\n\n  connect(token?: string): Promise<void> {\n    return new Promise((resolve, reject) => {\n      if (this.socket?.connected) {\n        resolve()\n        return\n      }\n\n      this.connectionStatus = 'connecting'\n      this.emit('connecting')\n\n      const serverUrl = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8080'\n      \n      this.socket = io(serverUrl, {\n        transports: ['websocket', 'polling'],\n        timeout: 10000,\n        auth: token ? { token } : undefined\n      })\n\n      this.socket.on('connect', () => {\n        console.log('Connected to collaboration server')\n        this.connectionStatus = 'connected'\n        this.reconnectAttempts = 0\n        this.emit('connected')\n        resolve()\n      })\n\n      this.socket.on('connect_error', (error) => {\n        console.error('Connection error:', error)\n        this.connectionStatus = 'error'\n        this.emit('connection-error', error)\n        reject(error)\n      })\n\n      this.socket.on('disconnect', (reason) => {\n        console.log('Disconnected:', reason)\n        this.connectionStatus = 'disconnected'\n        this.emit('disconnected', reason)\n        \n        // Auto-reconnect logic\n        if (reason === 'io server disconnect') {\n          // Server initiated disconnect, don't reconnect\n          return\n        }\n        \n        if (this.reconnectAttempts < this.maxReconnectAttempts) {\n          this.reconnectAttempts++\n          setTimeout(() => {\n            if (this.connectionStatus === 'disconnected') {\n              this.connect(token)\n            }\n          }, Math.pow(2, this.reconnectAttempts) * 1000) // Exponential backoff\n        }\n      })\n\n      // Document collaboration events\n      this.socket.on('document-joined', (data) => {\n        console.log('Document joined:', data)\n        this.emit('document-joined', data)\n      })\n\n      this.socket.on('user-joined', (data) => {\n        console.log('User joined:', data)\n        this.emit('user-joined', data)\n      })\n\n      this.socket.on('user-left', (data) => {\n        console.log('User left:', data)\n        this.emit('user-left', data)\n      })\n\n      this.socket.on('operation', (data) => {\n        console.log('Operation received:', data)\n        this.emit('operation', data)\n      })\n\n      this.socket.on('cursor-update', (data) => {\n        this.emit('cursor-update', data)\n      })\n\n      this.socket.on('error', (error) => {\n        console.error('Socket error:', error)\n        this.emit('error', error)\n      })\n    })\n  }\n\n  disconnect(): void {\n    if (this.socket) {\n      this.socket.disconnect()\n      this.socket = null\n    }\n    this.connectionStatus = 'disconnected'\n    this.currentDocumentId = null\n    this.reconnectAttempts = 0\n  }\n\n  async joinDocument(documentId: string, mode: CollaborationMode = 'live'): Promise<boolean> {\n    if (!this.socket?.connected) {\n      try {\n        await this.connect()\n      } catch (error) {\n        console.error('Failed to connect before joining document:', error)\n        return false\n      }\n    }\n\n    this.currentDocumentId = documentId\n    \n    this.socket!.emit('join-document', {\n      documentId,\n      mode,\n      userInfo: {\n        name: 'Current User',\n        avatar: ''\n      }\n    })\n\n    return true\n  }\n\n  sendOperation(operation: TextOperation): boolean {\n    if (!this.socket?.connected || !this.currentDocumentId) {\n      console.warn('Cannot send operation: not connected or no document')\n      return false\n    }\n\n    const enrichedOperation = {\n      ...operation,\n      userId: 'current-user',\n      timestamp: Date.now()\n    }\n\n    this.socket.emit('operation', {\n      documentId: this.currentDocumentId,\n      operation: enrichedOperation\n    })\n\n    return true\n  }\n\n  updateCursor(line: number, column: number): boolean {\n    if (!this.socket?.connected || !this.currentDocumentId) {\n      return false\n    }\n\n    this.socket.emit('cursor-update', {\n      documentId: this.currentDocumentId,\n      cursor: { line, column }\n    })\n\n    return true\n  }\n\n  on(event: string, callback: EventCallback): void {\n    if (!this.callbacks.has(event)) {\n      this.callbacks.set(event, [])\n    }\n    this.callbacks.get(event)!.push(callback)\n  }\n\n  off(event: string, callback: EventCallback): void {\n    const callbacks = this.callbacks.get(event)\n    if (callbacks) {\n      const index = callbacks.indexOf(callback)\n      if (index > -1) {\n        callbacks.splice(index, 1)\n      }\n    }\n  }\n\n  getConnectionStatus(): ConnectionStatus {\n    return this.connectionStatus\n  }\n\n  getCurrentDocumentId(): string | null {\n    return this.currentDocumentId\n  }\n\n  isConnected(): boolean {\n    return this.socket?.connected || false\n  }\n\n  private emit(event: string, data?: unknown): void {\n    const callbacks = this.callbacks.get(event)\n    if (callbacks) {\n      callbacks.forEach(callback => {\n        try {\n          callback(data)\n        } catch (error) {\n          console.error('Callback error:', error)\n        }\n      })\n    }\n  }\n}\n\nexport const realCollaborationService = RealCollaborationService.getInstance()